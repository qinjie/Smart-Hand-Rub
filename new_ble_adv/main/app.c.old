#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <driver/adc.h>

#include "esp_deep_sleep.h"
#include "esp_system.h"
//#include "ble.h"
#include "SimpleBLE.h"
#include "read_data.h"
#include "ulp_adc.h"

#include "driver/rtc_io.h"

#define GPIO_INPUT_IO_TRIGGER     2
#define GPIO_INPUT_IO_RESETCOUNT  13

#define period_time_wake_up_to_estimate_weight 5*1000000

#define THRESHOLDS_LOW 50
#define THRESHOLDS_PRESS 1500
#define GPIO_READ_ADC 34 // shouldn't change because it define in ulp_wakeup

#define storage "storage"
#define arrayName "arrayname"
#define sizeArray 5

void wakeupCause();
void setupPins(int firstPin, int secondPin);
void onPress();
void delay(int msSeconds);
void ulp_process(int threshold_press, int period);
void ulp_process_init(int threshold_press);
void ulp_process_start();
int getWeight();
void storeWeight(int weight);
void storeWeightToArray(int weight);
int getWeightStoredForReset();
void storeWeightForReset(int weight);
void setup();
void showArray();

void app_main() {
	//etupPins(GPIO_INPUT_IO_TRIGGER, GPIO_INPUT_IO_RESETCOUNT);
	wakeupCause();
	
	//printf("Enable timer wake up!\n");
	//esp_deep_sleep_enable_timer_wakeup(period_time_wake_up_to_estimate_weight);
	
	printf("Sleeping......\n");
	esp_deep_sleep_start();
	//startAdvertisingName("Mr Ngo Dat", 10);
	//vTaskDelay(5000 / portTICK_PERIOD_MS);
	//startAdvertisingName("Ahihi", 20);
	//endAdvertising();
}

void setup() {
	adc1_config_width(ADC_WIDTH_12Bit);
    adc1_config_channel_atten(ADC1_CHANNEL_6,ADC_ATTEN_0db);
}

void ulp_process_init(int threshold_press) {
	printf("Set ULP wake up press : %d \n",threshold_press);
	init_ulp_program(0, threshold_press, 100);
}

void ulp_process_start() {
	start_ulp_program();
	ESP_ERROR_CHECK( esp_deep_sleep_enable_ulp_wakeup() );
}

void ulp_process(int threshold_press, int period) {
	//deinit();
	printf("Set wake up press : %d \n",threshold_press);
	if (threshold_press > 2500)
		threshold_press = 2500;
	init_ulp_program(0, threshold_press, period);
	start_ulp_program();
	ESP_ERROR_CHECK( esp_deep_sleep_enable_ulp_wakeup() );
}

void showArray() {
	int store[sizeArray];
	getArrayValues(storage, arrayName, store, sizeArray);
	int i;
	for(i = 0; i < sizeArray; i++) {
		printf("Value at %d is %d \n", i, store[i]);
	}
	int numberArrayCur = getValueWithName(storage, "NumberOfRecord");
	if (numberArrayCur == -1) numberArrayCur = 0;
	
	int sumOfRecord = getValueWithName(storage, "SumOfRecord");
	if (sumOfRecord == -1) sumOfRecord = 0;
	
	int curPosition = getValueWithName(storage, "CurrentPosition");
	if (curPosition == -1) curPosition = 0;
	printf("NumberOfRecord %d, SumOfRecord %d, CurrentPosition %d \n", numberArrayCur, sumOfRecord, curPosition);
}

int getWeight() {
	int numberOfCount = 5;
	int i;
	int sum = 0;
	for(i = 0; i < numberOfCount; i++) {
		sum += adc1_get_voltage(ADC1_CHANNEL_6);
		delay(50);
	}
	return sum / numberOfCount;
}
// store and get for Reseting
void storeWeightForReset(int weight) {
	setValueWithName(storage, "Weight", weight);
}

int getWeightStoredForReset() {
	int weight = getValueWithName(storage, "Weight");
	return weight;
}

//algorithm get value sum minus value in position
void storeWeightToArray(int weight) {
	int numberArrayCur = getValueWithName(storage, "NumberOfRecord");
	if (numberArrayCur == -1) numberArrayCur = 0;
	
	int curPosition = getValueWithName(storage, "CurrentPosition");
	if (curPosition == -1) curPosition = 0;
	
	if (numberArrayCur < sizeArray) {
		curPosition = numberArrayCur;
		numberArrayCur++;
		setValueWithName(storage, "NumberOfRecord", numberArrayCur);
	} else {
		curPosition++;
		if (curPosition >= sizeArray) curPosition = 0;
	}
	
	storeValueAt(storage,arrayName,weight,curPosition);
	setValueWithName(storage, "CurrentPosition", curPosition);

}


void delay(int msSeconds) {
	vTaskDelay(msSeconds / portTICK_PERIOD_MS);
}

void onPress() {
	int serial = getValueWithName(storage, "serial");
	if (serial == -1) serial = 0;	
	serial++;
	int weight = getWeight();
	setValueWithName(storage, "serial", serial);
	
	char bufferSerial[snprintf(NULL, 0, "%d", serial) + 1];
	sprintf(bufferSerial, "%d", serial);
	char bufferWeight[snprintf(NULL, 0, "%d", weight) + 1];
	sprintf(bufferWeight, "%d", weight);
	
	char adv_data[26];
	strcpy(adv_data, bufferSerial);
	strcat(adv_data, " ");
	strcat(adv_data, bufferWeight);
	beginAdvertising(adv_data);
	showArray();
	delay(1000);
	int press = weight + THRESHOLDS_PRESS;
	ulp_process(press, 100000);
	//endAdvertising();
	
	//init ulp_wakeup
	//printf("Set wake up press : %d \n", THRESHOLDS_PRESS + weight);
	//ulp_process(THRESHOLDS_PRESS + weight, 100);
	
	//printf("Sleeping......\n");
	//esp_deep_sleep_start();
	//delay(5000);
}

void wakeupCause() {
	esp_deep_sleep_wakeup_cause_t cause = esp_deep_sleep_get_wakeup_cause();
    if (cause == ESP_DEEP_SLEEP_WAKEUP_ULP) {
		printf("Wake up from ULP wakeup\n");
		printf("Value of press = %d\n", getValueResultADC());
		printf("Counter = %d ", getCounter());
		onPress();
    } else if (cause == ESP_DEEP_SLEEP_WAKEUP_TIMER){
		// Get weight and store, after all reset
		//esp_deep_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);
		//esp_deep_sleep_pd_config(ESP_PD_DOMAIN_RTC_SLOW_MEM, ESP_PD_OPTION_ON);
		//printf("Wakeup from timer\n");
		//int weight = getWeight();
		//printf("Weight : %d \n", weight);
		//storeWeightForReset(weight);
		//int press = weight + THRESHOLDS_PRESS;
		//ulp_process(press, 100000);
		//showArray();
		//esp_restart();
    } else if (cause == ESP_DEEP_SLEEP_WAKEUP_EXT1) {
        uint64_t wakeup_pin_mask = esp_deep_sleep_get_ext1_wakeup_status();
        if (wakeup_pin_mask != 0) {
            int pin = __builtin_ffsll(wakeup_pin_mask) - 1;
            printf("Wake up from GPIO %d\n", pin);
            if (pin == GPIO_INPUT_IO_TRIGGER) {
					printf("Wake up from Trigger\n");
					
            } else if (pin == GPIO_INPUT_IO_RESETCOUNT) {
					printf("Wake up from reset count\n");
                }
        } else {
            printf("Wake up from GPIO\n");
        }
		// Get weight and store, after all reset
		printf("Wakeup from timer\n");
		int weight = getWeight();
		printf("Weight : %d \n", weight);
		storeWeightForReset(weight);
		
		int press = weight + THRESHOLDS_PRESS;
		esp_default_wake_deep_sleep();
		//REG_SET_FIELD(RTC_CNTL_REG, RTC_CNTL_DBIAS_WAK, 4);
		//REG_SET_FIELD(RTC_CNTL_REG, RTC_CNTL_DBIAS_SLP, 4);
		//esp_deep_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);
		//esp_deep_sleep_pd_config(ESP_PD_DOMAIN_RTC_SLOW_MEM, ESP_PD_OPTION_ON);
		//esp_deep_sleep_enable_ulp_wakeup();
		ulp_process(press, 100000);
		//showArray();
		//esp_restart();
    } else {
		//init_ulp_program();
		//printf("Wake up from RESET\n");
		//showArray();
		int weight = getWeightStoredForReset();
		if (weight != -1) {
			int press = weight + THRESHOLDS_PRESS;
			ulp_process(press, 100000);
			storeWeightForReset(-1);
		} else {
			weight = getWeight();
			storeWeightForReset(weight);
			esp_restart();
		}
	}
}
void setupPins(int firstPin, int secondPin) {
    esp_deep_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);
    const int ext_wakeup_pin_1 = firstPin;
    const int ext_wakeup_pin_2 = secondPin;
    //pinMode(GPIO_INPUT_IO_TRIGGER, INPUT_PULLDOWN);
    //pinMode(GPIO_INPUT_IO_RESETCOUNT, INPUT_PULLDOWN);
    const uint64_t ext_wakeup_pin_1_mask = 1LL << ext_wakeup_pin_1;
    const uint64_t ext_wakeup_pin_2_mask = 1LL << ext_wakeup_pin_2;
    esp_deep_sleep_enable_ext1_wakeup(ext_wakeup_pin_1_mask | ext_wakeup_pin_2_mask, ESP_EXT1_WAKEUP_ANY_HIGH);
}